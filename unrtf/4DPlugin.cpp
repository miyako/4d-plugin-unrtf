/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : UnRTF
 #	author : miyako
 #	2018/11/26
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"

std::mutex mutexUnRtf;

/* moved from main.c */

int nopict_mode; /* TRUE => Do not write \pict's to files */
int dump_mode;   /* TRUE => Output a dump of the RTF word tree */
int debug_mode;  /* TRUE => Output debug comments within HTML */
int lineno;      /* Used for error reporting and final line count. */
int simple_mode; /* TRUE => Output HTML without SPAN/DIV tags -- This would
                  probably be more useful if we could pull out <font> tags
                  as well. */
int inline_mode; /* TRUE => Output HTML without HTML/BODY/HEAD -- This is
                  buggy. I've seen it output pages of </font> tags. */
/* marcossamaral - 0.19.9 */
int verbose_mode;  /* TRUE => Output additional informations about unrtf */
int no_remap_mode; /* don't remap codepoints */
int quiet;       /* TRUE => don't output header comments */

OutputPersonality *op = NULL;
std::string *output = NULL;

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

		CommandDispatcher(pProcNum, pResult, pParams); 
	}
	catch(...)
	{

	}
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
// --- UnRTF

		case 1 :
			UnRTF(pResult, pParams);
			break;

	}
}

// ------------------------------------- UnRTF ------------------------------------

void user_init(UnRTF_Output format)
{
    CUTF8String path;
    
#if VERSIONMAC
    NSBundle *thisBundle = [NSBundle bundleWithIdentifier:THIS_BUNDLE_ID];
    if(thisBundle)
    {
        NSString *resourcePath = [thisBundle resourcePath];
        if(resourcePath)
        {
            C_TEXT t;
            t.setUTF16String(resourcePath);
            t.copyUTF8String(&path);
            path += (const uint8_t *)"/";
        }
    }
#else
    wchar_t fDrive[_MAX_DRIVE], fDir[_MAX_DIR], fName[_MAX_FNAME], fExt[_MAX_EXT];
    wchar_t thisPath[_MAX_PATH] = {0};
    
    HMODULE hplugin = GetModuleHandleW(THIS_BUNDLE_NAME);
    
    GetModuleFileNameW(hplugin, thisPath, _MAX_PATH);
    
    _wsplitpath_s(thisPath, fDrive, fDir, fName, fExt);
    std::wstring windowsPath = fDrive;
    windowsPath+= fDir;
    
    //remove delimiter to go one level up the hierarchy
    if(windowsPath.at(windowsPath.size() - 1) == L'\\')
        windowsPath = windowsPath.substr(0, windowsPath.size() - 1);
    
    _wsplitpath_s(windowsPath.c_str(), fDrive, fDir, fName, fExt);
    std::wstring resourcesPath = fDrive;
    resourcesPath += fDir;
    resourcesPath += L"Resources\\";
    
    C_TEXT t;
    t.setUTF16String((const PA_Unichar *)resourcesPath.c_str(), resourcesPath.length());
    t.copyUTF8String(&path);
    
#endif
    
    switch (format) {
        case UnRTF_Output_plain_text:
            path += (const uint8_t *)"text.conf";
            break;
        case UnRTF_Output_VT100:
            path += (const uint8_t *)"vt.conf";
            break;
        case UnRTF_Output_LaTeX:
            path += (const uint8_t *)"latex.conf";
            break;
        case UnRTF_Output_HTML:
        default:
            path += (const uint8_t *)"html.conf";
            break;
    }
    
    op = user_init(op, (char *)path.c_str());

}

FILE *ufopen(const char *filename, const char *mode);

#pragma mark -

void UnRTF(sLONG_PTR *pResult, PackagePtr pParams)
{
    C_TEXT Param1;
    C_LONGINT Param2;
    C_TEXT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);

    std::lock_guard<std::mutex> lock(mutexUnRtf);
    
    user_init((UnRTF_Output)Param2.getIntValue());
    
    lineno = 0;
    
    if(op != NULL)
    {
        CUTF8String path;
        Param1.copyPath(&path);
        
        FILE *f = ufopen((const char *)path.c_str(), "r");
        
        if(f)
        {
            Word *word = word_read(f);
            fclose(f);
            
            word = optimize_word(word, 1);
            
            output = new std::string();
            
            word_print(word);
            
            returnValue.setUTF8String((const uint8_t *)output->c_str(), output->length());
            
            delete output;
            
            if(word) word_free(word);
        }
    }
	returnValue.setReturn(pResult);
}

